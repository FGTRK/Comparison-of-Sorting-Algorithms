# Сравнение алгоритмов сортировки

Пусть необходимо отсортировать массив по возрастанию.

<h2>Быстрая сортировка (Хоара, quick sort). Самая лучшая из всех, что здесь написаны (n*logn)</h1>

Один из самых эффективных алгоритмов сортировки в общем случае. Он основан на принципе "разделяй и властвуй".

Процесс сортировки:
1. Выберите один элемент массива в качестве опорного элемента (pivot). Обычно берется средний элемент массива.
2. Разделите массив на две части: одна содержит элементы, которые меньше или равны опорному, и другая - элементы, которые больше опорного. Причем опорный окажется на своем месте.
3. Рекурсивно примените быструю сортировку к каждой из двух частей массива. Выходом из рекурсии служит длина массива = 1.

Это пример простой реализации, которая может быть улучшена оптимизациями. Одной из важных частей алгоритма является выбор опорного элемента, так чтобы он был достаточно хорошим приближением к медиане массива. Это может значительно уменьшить количество итераций и повысить производительность алгоритма.

```Python
def quickSort(mas, left, right):
    i, j = left, right
    pivot = mas[(i + j) // 2]
    while i <= j:
        while mas[i] < pivot:
            i += 1
        while mas[j] > pivot:
            j -= 1
        if i <= j:
            mas[i], mas[j] = mas[j], mas[i]
            i += 1
            j -= 1
    if j > left:
        quickSort(mas, left, j)
    if i < right:
        quickSort(mas, i, right)
```

<br></br>
<h2>Сортировка выбором. Самая лучшая после QuickSort O(n^2)</h1>

Это алгоритм сортировки, который на каждом шаге **выбирает** минимальный (или максимальный) элемент в неотсортированной части списка и помещает его в начало (или конец) отсортированной части.

Процесс сортировки:
1. Перебирается весь список и находится минимальный элемент.
2. Минимальный элемент меняется местами с первым элементом списка.
3. Второй проход начинается со второго элемента списка и снова находится минимальный элемент среди оставшихся.
4. Минимальный элемент меняется местами со вторым элементом списка.
5. Процесс повторяется, пока не будет отсортирован весь список.

```Python
def selectSort(mas):
    for i in range(len(mas)):
        min_ind = i
        for j in range(i, len(mas)):
            if mas[j] < mas[min_ind]:
                min_ind = j
        mas[i], mas[min_ind] = mas[min_ind], mas[i]
```

<br></br>
<h2>Сортировка вставками. Середнячок O(n^2)</h1>

Это алгоритм сортировки, который работает путем вставки элементов в отсортированную часть массива.

Процесс сортировки вставками выглядит следующим образом:
1. Изначально первый элемент считается отсортированным.
2. Взять следующий элемент и вставить его в правильное место в уже отсортированной части массива. Сравнить этот элемент с каждым элементом отсортированной части и вставить его перед элементом, который больше или равен данному элементу.
3. Повторить шаг 2 для каждого элемента массива, начиная со второго элемента.
4. Повторять шаги 2 и 3 до тех пор, пока все элементы не окажутся отсортированными.

```Python
def insertionSort(mas):
    for i in range(1, len(mas)):
        j = i
        while j > 0 and mas[j] < mas[j - 1]:
            mas[j], mas[j - 1] = mas[j - 1], mas[j]
            j -= 1
```

<br></br>
<h2>Сортировка обменами (пузырьковая). Очень плохо сортирует O(n^2)</h1>

ㅤㅤПроцесс сортировки:
1. Начинается сравнение первого и второго элементов списка. Если первый элемент больше второго, то они меняются местами.
2. Затем сравниваются второй и третий элементы и т.д. После каждого прохождения по списку, самый большой элемент "всплывает" на правильное место.
3. Процесс повторяется до тех пор, пока все элементы не будут отсортированы.

Этот алгоритм получил название "пузырьковая сортировка" из-за того, что наибольший элемент **всплывает** на правильное место, как пузырек в воде.

```Python
def bubbleSort(mas):
    for i in range(len(mas) - 1):
        for j in range(len(mas) - 1 - i):
            if mas[j] > mas[j + 1]:
                mas[j], mas[j + 1] = mas[j + 1], mas[j]
```
